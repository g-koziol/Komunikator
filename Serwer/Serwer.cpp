#pragma once
#include "stdafx.h"
#include "DLL.h"

#define WM_SOCKET 500
#define _CRTDBG_MAP_ALLOC

///reset gniazdka i uruchomienie ponownie pod innym miejsce
///przekodowac konstruktory server i client a by kod byl rozdzielony na funkcje
///dodac socket do deklaracji recive i send, a by dzialaly zaleznie od przyslanego argumentu
/// dodac obsluge wiadomosci
///dodac tablcie socketow i usuwanie niepotrzebnych socketow


#define _CRT_SECURE_NO_WARNINGS
using namespace std;
Server server(NULL);

ATOM				MyRegisterClass(HINSTANCE hInstance);
BOOL				InitInstance(HINSTANCE, int);
LRESULT CALLBACK	WinProc(HWND hWnd,UINT Message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK	Info(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	Settings(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK	Menu(HWND, UINT, WPARAM, LPARAM);

ATOM MyRegisterClass(HINSTANCE hInstance)
{//function which generates class for window
	WNDCLASSEX wClass;

	ZeroMemory(&wClass,sizeof(WNDCLASSEX));
	wClass.cbClsExtra=NULL;
	wClass.cbSize=sizeof(WNDCLASSEX);
	wClass.cbWndExtra=NULL;
	wClass.hbrBackground=(HBRUSH)COLOR_WINDOW;
	wClass.hCursor=LoadCursor(NULL,IDC_ARROW);
	wClass.hIcon=NULL;
	wClass.hIconSm=NULL;
	wClass.hInstance=hInstance;
	wClass.lpfnWndProc=WinProc;
	wClass.lpszClassName=L"WIN";
	wClass.lpszMenuName=MAKEINTRESOURCE(IDS_MENU);
	wClass.style=CS_HREDRAW|CS_VREDRAW;

	return RegisterClassEx(&wClass);
}

int APIENTRY _tWinMain(_In_ HINSTANCE hInstance,_In_opt_ HINSTANCE hPrevInstance,_In_ LPTSTR lpCmdLine,_In_ int nCmdShow)
{//function main for Window Application - mainly generated by environment
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);
	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	MyRegisterClass(hInstance);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow))
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDS_MENU));

	// Main Message loop:
	while (GetMessage(&msg, NULL, 0, 0))
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	return (int) msg.wParam;	
}

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{//new instance of window
	HWND hWnd;
	server.hInst = hInstance; // Store instance handle in our global variable

	hWnd = CreateWindowEx(NULL,
		L"WIN",
		L"Jarjar Klient",
		WS_OVERLAPPEDWINDOW ^ (WS_MAXIMIZEBOX| WS_THICKFRAME),
		200,
		200,
		640,
		800,
		NULL,
		NULL,
		hInstance,
		NULL);

	if (!hWnd)
	{
		return FALSE;
	}
	//ShowWindow(hWnd, nCmdShow);
	//UpdateWindow(hWnd);

	return TRUE;
}

LRESULT CALLBACK WinProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{//main function which operates with Messagess and notifications from windows, and controls
	switch(msg)
	{
	case WM_CREATE :
		{
			DialogBox(server.hInst, MAKEINTRESOURCE(IDS_MAIN), hWnd, Menu);			
		}
		break;

	case WM_DESTROY:
		{
			PostQuitMessage(0);			
			return 0;
		}
		break;

	case WM_CTLCOLORSTATIC:
		{
			HDC hEdit = (HDC)wParam;
			SetTextColor( hEdit, RGB(0, 0, 0) );
			SetBkColor  ( hEdit, RGB(255, 255, 255) );
			return (INT_PTR)GetStockObject( WHITE_BRUSH );
		}
		break;
	}
	return DefWindowProc(hWnd,msg,wParam,lParam);
}


INT_PTR CALLBACK Info(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{//function responsible for dialog box INFO
	UNREFERENCED_PARAMETER(lParam);
	switch (Message)
	{
	case WM_INITDIALOG:
		SetWindowText(GetDlgItem(hDlg,IDS_INFO_STATIC),(LPCWSTR)L"Komunikator JarJar\nSerwer\nby Grzegorz Kozioł\n\n\nProsze w ustawieniach wpisac adres IP serwera\n(lub zaznaczyć opcję przypisania IP z komputera)\nKliknac uruchom i serwer zacznie dzialac");
		return (INT_PTR)TRUE;

	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
		case IDS_INFO_OK:
			{
				EndDialog(hDlg, LOWORD(wParam));
				return (INT_PTR)TRUE;
			}
			break;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

INT_PTR CALLBACK Settings(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{//function responsible for dialog box SETTINGS
	LPARAM state=0;	
	HWND hIP=GetDlgItem(hDlg,IDS_SETTINGS_IPADDRESS), hCheck=GetDlgItem(hDlg,IDS_SETTINGS_CHECK);	

	struct hostent *host_entry=new hostent;

	UNREFERENCED_PARAMETER(lParam);
	switch (Message)
	{
	case WM_INITDIALOG:
		{			
			SendMessage(hIP,IPM_ISBLANK,NULL,state);
			if(!state)
				SendMessage(hIP,IPM_SETADDRESS,NULL,MAKEIPADDRESS(127,0,0,1));
			if(server.addr!=0)
				SendMessage(hIP,IPM_SETADDRESS,NULL,MAKEIPADDRESS(FIRST_IPADDRESS((LPARAM) server.addr),SECOND_IPADDRESS((LPARAM) server.addr),THIRD_IPADDRESS((LPARAM) server.addr),FOURTH_IPADDRESS((LPARAM) server.addr)));
			return (INT_PTR)TRUE;
		}
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDS_SETTINGS_OK:
			{	
				SendMessage(hIP,IPM_GETADDRESS,NULL,(LPARAM)&server.addr);					
				string a=server.setip(FIRST_IPADDRESS((LPARAM) server.addr),SECOND_IPADDRESS((LPARAM) server.addr),THIRD_IPADDRESS((LPARAM) server.addr),FOURTH_IPADDRESS((LPARAM) server.addr)).c_str();
				strcpy(server.szLocalIP,a.c_str());
				server.socketAddress.sin_addr.s_addr =inet_addr(server.szLocalIP);
				EndDialog(hDlg, LOWORD(wParam));
				delete host_entry;
				return (INT_PTR)TRUE;
			}
			break;
		case IDS_SETTINGS_CANCEL:
		case IDCANCEL:
			{
				SendMessage(hIP,IPM_SETADDRESS,NULL,MAKEIPADDRESS(FIRST_IPADDRESS((LPARAM) server.addr),SECOND_IPADDRESS((LPARAM) server.addr),THIRD_IPADDRESS((LPARAM) server.addr),FOURTH_IPADDRESS((LPARAM) server.addr)));			
				EndDialog(hDlg, LOWORD(wParam));
				delete host_entry;
				return (INT_PTR)TRUE;
			}
			break;
		case IDS_SETTINGS_CHECK:
			{
				state=SendMessage(hCheck,BM_GETCHECK,NULL,NULL);
				if(state==BST_CHECKED)
				{	
					WSAStartup(MAKEWORD(2,2),&server.wsaData);
					char * tmp=new char [256];		
					gethostname(tmp, sizeof(tmp));					
					host_entry=gethostbyname(tmp);	
					if(host_entry==NULL)
					{
						MessageBox(hDlg,(LPCWSTR)L"Nie udalo sie odczytac IP",(LPCWSTR)L"Blad",0);
						state==BST_UNCHECKED;
						delete tmp;
					}
					else{
						server.szLocalIP = inet_ntoa (*(struct in_addr *)*host_entry->h_addr_list);
						WSACleanup();
						strcpy(server.szLocalIP,tmp);
						delete tmp;
						SendMessage(hIP,IPM_SETADDRESS,NULL,MAKEIPADDRESS(((struct in_addr *)(host_entry->h_addr))->S_un.S_un_b.s_b1,((struct in_addr *)(host_entry->h_addr))->S_un.S_un_b.s_b2,((struct in_addr *)(host_entry->h_addr))->S_un.S_un_b.s_b3,((struct in_addr *)(host_entry->h_addr))->S_un.S_un_b.s_b4));
					}
				}
				else if(state==BST_UNCHECKED)
				{					
					SendMessage(hIP,IPM_SETADDRESS,NULL,MAKEIPADDRESS(127,0,0,1));
				}
			}
			break;
		}
		break;
	}
	return (INT_PTR)FALSE;
}

INT_PTR CALLBACK Menu(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{//function responsible for dialog box MAIN	
	try
	{
		UNREFERENCED_PARAMETER(lParam);
		switch (Message)
		{
		case WM_INITDIALOG:
			{			
				server.socketAddress.sin_addr.s_addr =inet_addr(LOCAL_IP);
				return (INT_PTR)TRUE;
			}
		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
			case IDS_MAIN_BUTTON_RUN:
				{		
					server.EditScreen=GetDlgItem(hDlg,IDS_MAIN_EDIT);
					server.start();
					try
					{
						if(WSAAsyncSelect(server.mainSocket, hDlg, WM_SOCKET, (FD_CLOSE|FD_ACCEPT|FD_READ)))
							throw ErrorSocket(server.EditScreen,WSAGetLastError());
					}
					catch(ErrorSocket x)
					{
						if(x.checknumber())
							return (INT_PTR)TRUE;
					}
					listen(server.mainSocket,SOMAXCONN);	
					ShowWindow(GetDlgItem(hDlg,IDS_MAIN_BUTTON_STOP),SW_SHOW);
					ShowWindow(GetDlgItem(hDlg,IDS_MAIN_BUTTON_RUN),SW_HIDE);
					return (INT_PTR)TRUE;
				}
				break;
			case IDS_MAIN_BUTTON_STOP:
				{
					ShowWindow(GetDlgItem(hDlg,IDS_MAIN_BUTTON_STOP),SW_HIDE);
					ShowWindow(GetDlgItem(hDlg,IDS_MAIN_BUTTON_RUN),SW_SHOW);
					server.apendtoedit(server.EditScreen,(LPARAM)L"Wylaczenie modolow sieciwych powiodlo sie\r\n");
					server.~Server();
					server.Server::Server(NULL);
				}
				break;
			case IDS_MENU_INFO:
				{
					DialogBox(server.hInst, MAKEINTRESOURCE(IDS_INFO), hDlg, Info);
				}
				break;
			case IDS_MENU_SETTINGS:
				{
					DialogBox(server.hInst, MAKEINTRESOURCE(IDS_SETTINGS), hDlg, Settings);
				}
				break;
			case IDCANCEL:
			case IDS_MENU_EXIT:
			//case ID_EXIT:
				PostQuitMessage(0);
				return (INT_PTR)FALSE;	
			}

		case WM_SOCKET: //operating with Socket Messagess
			{
				switch(WSAGETSELECTEVENT(lParam))
				{
				case FD_READ:
					{ 
						if(server.data!=NULL)
						{
							int i=0;
							while(server.data[i]!=NULL)
							{											
								if(server.data[i]->status==1)
								{ 
									User * tmpu=server._reciveUserdatafromUser(server.newsocket,server.data);
									if(tmpu==NULL)
									{	
										class Message * tmpm=new class Message("User_exists","","","",1);
										server._send(tmpm,server.data[i]->socketClient);
										delete tmpm;
										delete server.data[i];
										server.data[i]=NULL;
										break;
									}
									server.data=server.addUsertodata(tmpu, server.newsocket);
									server.newsocket=SOCKET_ERROR;							
									server.data[i]->status=2;
									string a="Client " + server.data[i]->name + " is connected\r\n";
									TCHAR * str=server.chartotchar(a.c_str());
									server.apendtoedit(server.EditScreen,(LPARAM)str);
									delete tmpu;
									delete str;
								}
								i+=1;
							}
							i=0;
							while(server.data[i]!=NULL)
							{
								if(server.data[i]->status==2)
								{
									class Message * msg=NULL;
									msg=server._recive(server.data[i]->socketClient);
									server.action(msg);
									delete msg;
									msg=NULL;
								}
								i++;
							}
							server.readpipetab(server.EditScreen);							
						}
					}
					break;

				case FD_CLOSE:
					{
						int i=server.findclosedsocket();
						if(server.data[i]!=NULL)
						{					
							string a = "Client " + server.data[i]->name + " is disconnected\r\n";
							TCHAR * str=server.chartotchar(a.c_str());
							server.deletesocket(i);
							server.apendtoedit(server.EditScreen,(LPARAM)str);
							delete str;
						}

					}
					break;

				case FD_ACCEPT:
					{
						int size=sizeof(sockaddr);
						server.newsocket=accept(wParam,(SOCKADDR *)&server.socketAddress,&size);										
						int i=0;
						if(server.data==NULL)
						{
							server.data=new User *;
							server.data[0]=NULL;
						}
						while(server.data[i]!=NULL)						
							i++;					
						server.data[i]=new User;					
						server.data[i]->status=1;
						server.data[i+1]=NULL;
						server.data[i]->socketClient=server.newsocket;					
					} 
					break;
				}
			}
		}
	}
	catch(...)
	{		
		MemoryDump m(server.data);
		m.writememory();
	}
	return (INT_PTR)FALSE;
}


